/**
 * Code generated by Microsoft (R) AutoRest Code Generator 1.0.1.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package silica.implementation;

import silica.MASTERTEMPLATE;
import silica.GetSystemApis;
import silica.GetSystemSessionApis;
import silica.GetSystemUseragentApis;
import silica.GetSystemGeneratesdkApis;
import com.microsoft.rest.ServiceClient;
import com.microsoft.rest.RestClient;
import okhttp3.OkHttpClient;
import retrofit2.Retrofit;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.Headers;
import retrofit2.http.POST;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;
import silica.models.Model1;

/**
 * Initializes a new instance of the MASTERTEMPLATE class.
 */
public class MASTERTEMPLATEImpl extends ServiceClient implements MASTERTEMPLATE {
    /**
     * The Retrofit service to perform REST calls.
     */
    private MASTERTEMPLATEService service;

    /**
     * The GetSystemApis object to access its operations.
     */
    private GetSystemApis getSystemApis;

    /**
     * Gets the GetSystemApis object to access its operations.
     * @return the GetSystemApis object.
     */
    public GetSystemApis getSystemApis() {
        return this.getSystemApis;
    }

    /**
     * The GetSystemSessionApis object to access its operations.
     */
    private GetSystemSessionApis getSystemSessionApis;

    /**
     * Gets the GetSystemSessionApis object to access its operations.
     * @return the GetSystemSessionApis object.
     */
    public GetSystemSessionApis getSystemSessionApis() {
        return this.getSystemSessionApis;
    }

    /**
     * The GetSystemUseragentApis object to access its operations.
     */
    private GetSystemUseragentApis getSystemUseragentApis;

    /**
     * Gets the GetSystemUseragentApis object to access its operations.
     * @return the GetSystemUseragentApis object.
     */
    public GetSystemUseragentApis getSystemUseragentApis() {
        return this.getSystemUseragentApis;
    }

    /**
     * The GetSystemGeneratesdkApis object to access its operations.
     */
    private GetSystemGeneratesdkApis getSystemGeneratesdkApis;

    /**
     * Gets the GetSystemGeneratesdkApis object to access its operations.
     * @return the GetSystemGeneratesdkApis object.
     */
    public GetSystemGeneratesdkApis getSystemGeneratesdkApis() {
        return this.getSystemGeneratesdkApis;
    }

    /**
     * Initializes an instance of MASTERTEMPLATE client.
     */
    public MASTERTEMPLATEImpl() {
        this("http://localhost:8082/");
    }

    /**
     * Initializes an instance of MASTERTEMPLATE client.
     *
     * @param baseUrl the base URL of the host
     */
    public MASTERTEMPLATEImpl(String baseUrl) {
        super(baseUrl);
        initialize();
    }

    /**
     * Initializes an instance of MASTERTEMPLATE client.
     *
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public MASTERTEMPLATEImpl(OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        this("http://localhost:8082/", clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of MASTERTEMPLATE client.
     *
     * @param baseUrl the base URL of the host
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public MASTERTEMPLATEImpl(String baseUrl, OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        super(baseUrl, clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of MASTERTEMPLATE client.
     *
     * @param restClient the REST client containing pre-configured settings
     */
    public MASTERTEMPLATEImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    private void initialize() {
        this.getSystemApis = new GetSystemApisImpl(retrofit(), this);
        this.getSystemSessionApis = new GetSystemSessionApisImpl(retrofit(), this);
        this.getSystemUseragentApis = new GetSystemUseragentApisImpl(retrofit(), this);
        this.getSystemGeneratesdkApis = new GetSystemGeneratesdkApisImpl(retrofit(), this);
        initializeService();
    }

    private void initializeService() {
        service = retrofit().create(MASTERTEMPLATEService.class);
    }

    /**
     * The interface defining all the services for MASTERTEMPLATE to be
     * used by Retrofit to perform actually REST calls.
     */
    interface MASTERTEMPLATEService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: silica.MASTERTEMPLATE pingApi" })
        @GET("System/API_Ping/{API_Key}/")
        Observable<Response<ResponseBody>> pingApi(@Path("API_Key") String aPIKey);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: silica.MASTERTEMPLATE key" })
        @GET("System/Session/{API_Key}/")
        Observable<Response<ResponseBody>> key(@Path("API_Key") String aPIKey);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: silica.MASTERTEMPLATE key" })
        @GET("System/UserAgent/{API_Key}/")
        Observable<Response<ResponseBody>> key(@Path("API_Key") String aPIKey);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: silica.MASTERTEMPLATE keySwaggerjsonurlLanguageNamespace" })
        @GET("System/GenerateSDK/{API_Key}/{swaggerJSONurl}/{language}/{namespace}")
        Observable<Response<ResponseBody>> keySwaggerjsonurlLanguageNamespace(@Path("API_Key") String aPIKey, @Path("swaggerJSONurl") String swaggerJSONurl, @Path("language") String language, @Path("namespace") String namespace);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: silica.MASTERTEMPLATE postUserRefreshtokenforuseraccount" })
        @POST("User/RefreshTokenForUserAccount/")
        Observable<Response<ResponseBody>> postUserRefreshtokenforuseraccount(@Body Model1 body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: silica.MASTERTEMPLATE postUserRegisteraccounttoreceivetoken" })
        @POST("User/RegisterAccountToReceiveToken/")
        Observable<Response<ResponseBody>> postUserRegisteraccounttoreceivetoken(@Body Model1 body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: silica.MASTERTEMPLATE postUserRequestaudittrail" })
        @POST("User/RequestAuditTrail/")
        Observable<Response<ResponseBody>> postUserRequestaudittrail(@Body Model1 body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: silica.MASTERTEMPLATE postUserRetrievetokenforuseraccount" })
        @POST("User/RetrieveTokenForUserAccount/")
        Observable<Response<ResponseBody>> postUserRetrievetokenforuseraccount(@Body Model1 body);

    }

    /**
     * Step 3. Create new user account bearer token.
     * Step 3. Create a new bearer token associated with the user account.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void postUserRefreshtokenforuseraccount() {
        postUserRefreshtokenforuseraccountWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Step 3. Create new user account bearer token.
     * Step 3. Create a new bearer token associated with the user account.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> postUserRefreshtokenforuseraccountAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(postUserRefreshtokenforuseraccountWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Step 3. Create new user account bearer token.
     * Step 3. Create a new bearer token associated with the user account.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> postUserRefreshtokenforuseraccountAsync() {
        return postUserRefreshtokenforuseraccountWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Step 3. Create new user account bearer token.
     * Step 3. Create a new bearer token associated with the user account.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> postUserRefreshtokenforuseraccountWithServiceResponseAsync() {
        final Model1 body = null;
        return service.postUserRefreshtokenforuseraccount(body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = postUserRefreshtokenforuseraccountDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Step 3. Create new user account bearer token.
     * Step 3. Create a new bearer token associated with the user account.
     *
     * @param body the Model1 value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void postUserRefreshtokenforuseraccount(Model1 body) {
        postUserRefreshtokenforuseraccountWithServiceResponseAsync(body).toBlocking().single().body();
    }

    /**
     * Step 3. Create new user account bearer token.
     * Step 3. Create a new bearer token associated with the user account.
     *
     * @param body the Model1 value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> postUserRefreshtokenforuseraccountAsync(Model1 body, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(postUserRefreshtokenforuseraccountWithServiceResponseAsync(body), serviceCallback);
    }

    /**
     * Step 3. Create new user account bearer token.
     * Step 3. Create a new bearer token associated with the user account.
     *
     * @param body the Model1 value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> postUserRefreshtokenforuseraccountAsync(Model1 body) {
        return postUserRefreshtokenforuseraccountWithServiceResponseAsync(body).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Step 3. Create new user account bearer token.
     * Step 3. Create a new bearer token associated with the user account.
     *
     * @param body the Model1 value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> postUserRefreshtokenforuseraccountWithServiceResponseAsync(Model1 body) {
        Validator.validate(body);
        return service.postUserRefreshtokenforuseraccount(body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = postUserRefreshtokenforuseraccountDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> postUserRefreshtokenforuseraccountDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .build(response);
    }

    /**
     * Step 1. Create a user account.
     * Step 1. Create a new user account to allow API interaction.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void postUserRegisteraccounttoreceivetoken() {
        postUserRegisteraccounttoreceivetokenWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Step 1. Create a user account.
     * Step 1. Create a new user account to allow API interaction.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> postUserRegisteraccounttoreceivetokenAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(postUserRegisteraccounttoreceivetokenWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Step 1. Create a user account.
     * Step 1. Create a new user account to allow API interaction.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> postUserRegisteraccounttoreceivetokenAsync() {
        return postUserRegisteraccounttoreceivetokenWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Step 1. Create a user account.
     * Step 1. Create a new user account to allow API interaction.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> postUserRegisteraccounttoreceivetokenWithServiceResponseAsync() {
        final Model1 body = null;
        return service.postUserRegisteraccounttoreceivetoken(body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = postUserRegisteraccounttoreceivetokenDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Step 1. Create a user account.
     * Step 1. Create a new user account to allow API interaction.
     *
     * @param body the Model1 value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void postUserRegisteraccounttoreceivetoken(Model1 body) {
        postUserRegisteraccounttoreceivetokenWithServiceResponseAsync(body).toBlocking().single().body();
    }

    /**
     * Step 1. Create a user account.
     * Step 1. Create a new user account to allow API interaction.
     *
     * @param body the Model1 value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> postUserRegisteraccounttoreceivetokenAsync(Model1 body, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(postUserRegisteraccounttoreceivetokenWithServiceResponseAsync(body), serviceCallback);
    }

    /**
     * Step 1. Create a user account.
     * Step 1. Create a new user account to allow API interaction.
     *
     * @param body the Model1 value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> postUserRegisteraccounttoreceivetokenAsync(Model1 body) {
        return postUserRegisteraccounttoreceivetokenWithServiceResponseAsync(body).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Step 1. Create a user account.
     * Step 1. Create a new user account to allow API interaction.
     *
     * @param body the Model1 value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> postUserRegisteraccounttoreceivetokenWithServiceResponseAsync(Model1 body) {
        Validator.validate(body);
        return service.postUserRegisteraccounttoreceivetoken(body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = postUserRegisteraccounttoreceivetokenDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> postUserRegisteraccounttoreceivetokenDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .build(response);
    }

    /**
     * Step 3. Create new user account bearer token.
     * Step 3. Create a new bearer token associated with the user account.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void postUserRequestaudittrail() {
        postUserRequestaudittrailWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Step 3. Create new user account bearer token.
     * Step 3. Create a new bearer token associated with the user account.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> postUserRequestaudittrailAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(postUserRequestaudittrailWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Step 3. Create new user account bearer token.
     * Step 3. Create a new bearer token associated with the user account.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> postUserRequestaudittrailAsync() {
        return postUserRequestaudittrailWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Step 3. Create new user account bearer token.
     * Step 3. Create a new bearer token associated with the user account.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> postUserRequestaudittrailWithServiceResponseAsync() {
        final Model1 body = null;
        return service.postUserRequestaudittrail(body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = postUserRequestaudittrailDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Step 3. Create new user account bearer token.
     * Step 3. Create a new bearer token associated with the user account.
     *
     * @param body the Model1 value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void postUserRequestaudittrail(Model1 body) {
        postUserRequestaudittrailWithServiceResponseAsync(body).toBlocking().single().body();
    }

    /**
     * Step 3. Create new user account bearer token.
     * Step 3. Create a new bearer token associated with the user account.
     *
     * @param body the Model1 value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> postUserRequestaudittrailAsync(Model1 body, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(postUserRequestaudittrailWithServiceResponseAsync(body), serviceCallback);
    }

    /**
     * Step 3. Create new user account bearer token.
     * Step 3. Create a new bearer token associated with the user account.
     *
     * @param body the Model1 value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> postUserRequestaudittrailAsync(Model1 body) {
        return postUserRequestaudittrailWithServiceResponseAsync(body).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Step 3. Create new user account bearer token.
     * Step 3. Create a new bearer token associated with the user account.
     *
     * @param body the Model1 value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> postUserRequestaudittrailWithServiceResponseAsync(Model1 body) {
        Validator.validate(body);
        return service.postUserRequestaudittrail(body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = postUserRequestaudittrailDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> postUserRequestaudittrailDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .build(response);
    }

    /**
     * Step 2. Retrieve user account bearer token.
     * Step 2. Return the bearer token associated with the user account.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void postUserRetrievetokenforuseraccount() {
        postUserRetrievetokenforuseraccountWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Step 2. Retrieve user account bearer token.
     * Step 2. Return the bearer token associated with the user account.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> postUserRetrievetokenforuseraccountAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(postUserRetrievetokenforuseraccountWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Step 2. Retrieve user account bearer token.
     * Step 2. Return the bearer token associated with the user account.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> postUserRetrievetokenforuseraccountAsync() {
        return postUserRetrievetokenforuseraccountWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Step 2. Retrieve user account bearer token.
     * Step 2. Return the bearer token associated with the user account.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> postUserRetrievetokenforuseraccountWithServiceResponseAsync() {
        final Model1 body = null;
        return service.postUserRetrievetokenforuseraccount(body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = postUserRetrievetokenforuseraccountDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Step 2. Retrieve user account bearer token.
     * Step 2. Return the bearer token associated with the user account.
     *
     * @param body the Model1 value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void postUserRetrievetokenforuseraccount(Model1 body) {
        postUserRetrievetokenforuseraccountWithServiceResponseAsync(body).toBlocking().single().body();
    }

    /**
     * Step 2. Retrieve user account bearer token.
     * Step 2. Return the bearer token associated with the user account.
     *
     * @param body the Model1 value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> postUserRetrievetokenforuseraccountAsync(Model1 body, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(postUserRetrievetokenforuseraccountWithServiceResponseAsync(body), serviceCallback);
    }

    /**
     * Step 2. Retrieve user account bearer token.
     * Step 2. Return the bearer token associated with the user account.
     *
     * @param body the Model1 value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> postUserRetrievetokenforuseraccountAsync(Model1 body) {
        return postUserRetrievetokenforuseraccountWithServiceResponseAsync(body).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Step 2. Retrieve user account bearer token.
     * Step 2. Return the bearer token associated with the user account.
     *
     * @param body the Model1 value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> postUserRetrievetokenforuseraccountWithServiceResponseAsync(Model1 body) {
        Validator.validate(body);
        return service.postUserRetrievetokenforuseraccount(body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = postUserRetrievetokenforuseraccountDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> postUserRetrievetokenforuseraccountDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .build(response);
    }

}
